[{"title":"抗遗忘：Go Ticker 笔记","path":"/2024/05/09/抗遗忘：Go-Ticker-笔记/","content":"time.Ticker 是周期性定时器，按指定的时间间隔重复向 Channel (C) 发送时间值。通过实例 ticker.Stop() 可以停止定时器。如果只想返回一个时间值，而不必关闭它，这个时候可以选择使用 time.Tick() 方法。 输出间隔时间值创建一个定时器，每隔 1 秒发送一次当前时间，在 main 函数中使用 time.Sleep(5 * time.Second) 等待 5 秒给定时器所在的协程执行，5 秒后主函数退出时内部的协程也将被终止，所以输出了 4 次日志。 除了使用时间去阻塞主协程外，我们还可以利用 Channel 在什么情况下会阻塞当前协程来实现 main 函数一直挂起，比如：make(chan struct&#123;&#125;) &lt;- struct&#123;&#125;&#123;&#125;，&lt;-make(chan struct&#123;&#125;), &lt;-chan struct&#123;&#125;)(nil) 和 select&#123;&#125;，当然我们也可以暴力直接写一个 for&#123;&#125;。 12345678910111213141516171819package mainimport (\t&quot;log&quot;\t&quot;time&quot;)func main() &#123;\tticker := time.NewTicker(time.Second)\tdefer ticker.Stop()\tgo func() &#123; for t := range ticker.C &#123; log.Printf(&quot;Tick at %v &quot;, t.UTC()) &#125;\t&#125;()\ttime.Sleep(5 * time.Second)&#125; 输出： 12342024/04/10 15:15:03 Tick at 2024-04-10 07:15:03.9905864 +0000 UTC2024/04/10 15:15:04 Tick at 2024-04-10 07:15:04.9827231 +0000 UTC2024/04/10 15:15:05 Tick at 2024-04-10 07:15:05.989957 +0000 UTC2024/04/10 15:15:06 Tick at 2024-04-10 07:15:06.980916 +0000 UTC 立即执行，不用等待第一次间隔上一个示例中如果我们在 main() 函数内第一行加上 fmt.Println(&quot;Starting ticker: &quot;, time.Now().UTC())，查看终端输出会发现实际上是间隔了我们设定的间隔值才输出定时器发送的时间值。如果我们需要在 for 中立即拿到定时器发送的时间，可以这样子来实现： 123456789101112131415161718192021package mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;time&quot;)func main() &#123;\tfmt.Println(&quot;Starting ticker: &quot;, time.Now().UTC())\tticker := time.NewTicker(time.Second)\tdefer ticker.Stop()\tgo func() &#123; for ; ; &lt;-ticker.C &#123; log.Printf(&quot;Tick at %v &quot;, time.Now().UTC()) &#125;\t&#125;()\ttime.Sleep(5 * time.Second)&#125; 输出： 123456Starting ticker: 2024-04-10 07:57:05.6394014 +0000 UTC2024/04/10 15:57:05 Tick at 2024-04-10 07:57:05.6394014 +0000 UTC2024/04/10 15:57:06 Tick at 2024-04-10 07:57:06.6450901 +0000 UTC2024/04/10 15:57:07 Tick at 2024-04-10 07:57:07.6513953 +0000 UTC2024/04/10 15:57:08 Tick at 2024-04-10 07:57:08.6409958 +0000 UTC2024/04/10 15:57:09 Tick at 2024-04-10 07:57:09.6480314 +0000 UTC 上面的代码中我们注意到 for ; ; &lt;-ticker.C 这里我们并没有读取定时器发送过来的时间，并且日志输出的时间是使用的 time.Now().UTC()，这种方式并不是很好的实践，还可能存在意想不到的副作用，所以改成下面这种方式才是最佳实践： 123for t := time.Now(); ; t = &lt;-ticker.C &#123;\tlog.Printf(&quot;Tick at: %v &quot;, t.UTC())&#125; 停止发送，并关闭 Channel我们调用 ticker.Stop() 只是停止了定时器再次发送值，并没有关闭 Channel，要关闭 Channel 还需要一个额外信号来通知关闭。 1234567891011121314151617181920212223242526package mainimport (\t&quot;fmt&quot;\t&quot;time&quot;)func main() &#123;\tticker := time.NewTicker(time.Second)\tdone := make(chan bool)\tgo func() &#123; for &#123; select &#123; case &lt;-done: return case t := &lt;-ticker.C: fmt.Println(&quot;Tick at&quot;, t.UTC()) &#125; &#125;\t&#125;()\ttime.Sleep(5 * time.Second)\tticker.Stop()\tdone &lt;- true\tfmt.Println(&quot;Ticker stopped&quot;)&#125; 输出： 123456Tick at 2024-04-10 08:53:42.403751 +0000 UTCTick at 2024-04-10 08:53:43.3943259 +0000 UTCTick at 2024-04-10 08:53:44.4026484 +0000 UTCTick at 2024-04-10 08:53:45.3922398 +0000 UTCTick at 2024-04-10 08:53:46.400103 +0000 UTCTicker stopped 根据条件关闭定时器每隔一秒给 counter 加一，当其值大于 5 时关闭定时器，并退出。 123456789101112131415161718192021222324package mainimport (\t&quot;fmt&quot;\t&quot;time&quot;)func main() &#123;\tticker := time.NewTicker(time.Second)\tcounter := 0\tfor &#123; select &#123; case &lt;-ticker.C: counter++ fmt.Println(&quot;Counter:&quot;, counter) if counter &gt;= 5 &#123; ticker.Stop() fmt.Println(&quot;Ticker stopped&quot;) return &#125; &#125;\t&#125;&#125; 举个公交车场景例子公交车每隔5分钟发一班，不管是否已坐满乘客，已经坐满乘客情况下，不足五分钟也发车。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport (\t&quot;fmt&quot;\t&quot;math/rand&quot;\t&quot;time&quot;)type Passenger struct&#123; id int &#125;type Bus struct &#123;\tmaxCap int\tpassengers []Passenger\tcap int&#125;func NewBus(maxCap int) *Bus &#123;\treturn &amp;Bus&#123; maxCap: maxCap, passengers: make([]Passenger, 0), cap: 0,\t&#125;&#125;func (b *Bus) AddPassenger(p Passenger) &#123;\tif b.cap &lt; b.maxCap &#123; fmt.Printf(&quot;乘客#%d 上车 &quot;, p.id) b.passengers = append(b.passengers, p) b.cap++ time.Sleep(time.Duration(rand.Intn(5000)) * time.Millisecond) fmt.Printf(&quot;乘客#%d 下车 &quot;, p.id) b.passengers = DeleteSlice(b.passengers, p) b.cap-- fmt.Println(&quot;当前乘客：&quot;, b.passengers)\t&#125; else &#123; done &lt;- true\t&#125;&#125;var done = make(chan bool)func main() &#123;\tbus := NewBus(50)\tticker := time.NewTicker(3 * time.Second)\tdefer ticker.Stop()\tfor passengerId := 0; ; passengerId++ &#123; select &#123; case &lt;-done: fmt.Println(&quot;座位满了&quot;) return case &lt;-ticker.C: fmt.Println(&quot;时间到了，开始发车，总人数：&quot;, bus.cap) return default: time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond) passenger := Passenger&#123;id: passengerId&#125; go bus.AddPassenger(passenger) &#125;\t&#125;&#125;// 删除切片中的元素func DeleteSlice(s []Passenger, elem Passenger) []Passenger &#123;\tr := s[:0]\tfor _, v := range s &#123; if v != elem &#123; r = append(r, v) &#125;\t&#125;\treturn r&#125; 时间到了输出： 123456789101112131415161718192021222324乘客#0 上车乘客#1 上车乘客#2 上车乘客#3 上车乘客#4 上车乘客#3 下车当前乘客： [&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;4&#125;]乘客#5 上车乘客#6 上车乘客#6 下车当前乘客： [&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;4&#125; &#123;5&#125;]乘客#7 上车乘客#0 下车当前乘客： [&#123;1&#125; &#123;2&#125; &#123;4&#125; &#123;5&#125; &#123;7&#125;]乘客#8 上车乘客#9 上车乘客#1 下车当前乘客： [&#123;2&#125; &#123;4&#125; &#123;5&#125; &#123;7&#125; &#123;8&#125; &#123;9&#125;]乘客#10 上车乘客#9 下车当前乘客： [&#123;2&#125; &#123;4&#125; &#123;5&#125; &#123;7&#125; &#123;8&#125; &#123;10&#125;]乘客#4 下车当前乘客： [&#123;2&#125; &#123;5&#125; &#123;7&#125; &#123;8&#125; &#123;10&#125;]时间到了，开始发车，总人数： 5 将人数设置为 3 人，下车的时间设置成 time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) 输出： 12345678910111213141516乘客#0 上车乘客#1 上车乘客#2 上车乘客#0 下车当前乘客： [&#123;1&#125; &#123;2&#125;]乘客#2 下车当前乘客： [&#123;1&#125;]乘客#3 上车乘客#1 下车当前乘客： [&#123;3&#125;]乘客#4 上车乘客#5 上车乘客#3 下车当前乘客： [&#123;4&#125; &#123;5&#125;]乘客#7 上车座位满了 参考： go定时器–Ticker - failymao - 博客园 (cnblogs.com) 5 different ways to loop over a time.Ticker in Go (Golang) (gosamples.dev) Some Simple Summaries -Go 101","tags":["Go"]},{"title":"Obsidian 达人成长之路","path":"/2024/05/09/Obsidian-达人成长之路-1：使用终极工具-Dataview-释放笔记库的潜力-·-DQL查询语言/","content":"hhhh","tags":["Obsidian","Dataview"]},{"title":"Hello World","path":"/2024/04/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 亮 暗 警告 错误 一共 12 种颜色。"},{"title":"About","path":"/about/index.html","content":"人在 2024 年，博客还没开始写，但是我已经在努力写博客了。"}]